# malloc

В этой задаче вам предлагается написать свою реализацию функций `malloc`, `calloc`, `realloc` и `free` из стандартной библиотеки языка Си. Можно пользоваться средствами C++,  кроме тех, которые позволяют выделять динамическую память (то есть `new`/`delete` и стандартные контейнеры, очевидно, использовать нельзя).

Как компилировать код, чтобы он использовал ваши версии `malloc`/`free` вместо стандартных, описано [здесь](https://www.gnu.org/software/libc/manual/html_node/Replacing-malloc.html).

В общих чертах почитать об алгоритме работы стандартного `malloc` можно [здесь](https://sourceware.org/glibc/wiki/MallocInternals).
Если ссылка не работает, то архивная копия [здесь](https://web.archive.org/web/20231111054353/https://sourceware.org/glibc/wiki/MallocInternals).

Наиболее полное и понятное (на мой взгляд) описание шагов, которые должен делать `malloc`, приведено [здесь](https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/). Полезно также почитать и другие статьи оттуда.

Нужно написать идейно похожий, но сильно упрощенный алгоритм `malloc` по сравнению со стандартным из `glibc`. Поддерживать многопоточность (то есть возможность конкурентно вызывать `malloc` из разных тредов) не нужно.

Общее описание, как примерно должен вести себя ваш `malloc`:
- Если просят достаточно большой кусок памяти (более чем `MMAP_THRESHOLD`, пусть это будет `128` КБ) - выделяем его через `mmap`, в противном случае пользуемся `brk`
- Поддерживаем набор чанков разных размеров, меньших `128` КБ. Существуют “малые чанки” и “большие чанки”. Большими будем считать те, которые превосходят `512` байт. Малые чанки должны быть всех возможных размеров, кратных `16`, от `16` до `512` байт. Поскольку `malloc` всегда должен возвращать адреса, выровненные по `16`, то минимальный размер чанка равен `16`. Большие чанки уже не должны быть всех возможных размеров, но множество их возможных размеров заранее фиксировано (возможные размеры увеличиваются экспоненциально после `512` байт).
- Когда нас просят выделить память, берем наименьший подходящий размер чанка и либо находим свободный чанк такого рамера, либо создаем новый.
- Чанки в памяти лежат подряд. Каждый чанк хранит в начале и в конце свой размер (см. статьи по ссылкам выше или лекцию). Свободен ли чанк – кодируется одним битом в конце числа, кодирующего размер.
- Помимо непрерывного куска памяти, где лежат чанки, храним еще массив из связных списков свободных чанков всевозможных размеров. Когда чанк свободен, его байты мы переиспользуем для того, чтобы сохранить в них указатели на предыдущий и на следующий элемент связного списка. Изначально все связные списки пусты, чанков нет, их нужно создавать через `brk`.

Как ведет себя `free`:
- Если наш чанк был выделен с помощью mmap, то освобождаем его через `munmap`.
- Иначе помечаем наш чанк свободным. Соответственно обновляем связные списки, добавляем информацию об этом в прилегающие чанки. Если при этом мы можем объединить освободившийся чанк с соседними, так чтобы получить свободный чанк большего размера, то делаем это.
- Если нас просят `free` от пойнтера, а чанк уже свободен, то мы выводим сообщение `double free detected` и падаем с вердиктом `Aborted` (как это делает стандартный `free`). Аналогично мы должны себя вести, если поняли, что просят `free` не от начала чанка или от пойнтера, который вообще не относится к какому-либо чанку (но текст сообщения об ошибке должен быть другим).

Функция `calloc` отличается от `malloc` только тем, что изначально инициализирует выделяемую память.

Как работает `realloc`:
- Если наш чанк был выделен с помощью `mmap`, то пытаемся его увеличить с помощью `mremap`.
- Иначе смотрим, нет ли в нашем чанке достаточного свободного места. А также смотрим, нет ли по соседству от нашего чанка свободных чанков такого размера, чтобы объединить наш чанк с ними и получить чанк большего размера.
- Если мы понимаем, что переданный нам указатель вообще не относится ни к какому чанку, или не является началом чанка, или что угодно еще, то мы должны вывести сообщение об ошибке и упасть с вердиктом `Aborted`.

P.S. При реализации, стоит отдавать приоритет поведению в краевых случаях, размерам и лимитам описанных в приведенных статьях (а не в readme) для 64-bit систем